- name: Windows Security Audit
  hosts: windows
  gather_facts: no
  tasks:

    # --- Local accounts ---
    - name: Check Administrator account
      win_shell: '(Get-LocalUser -Name "Administrator").Enabled'
      register: admin_enabled

    - name: Record Administrator account status
      debug:
        msg:
          task: "Administrator account"
          msg: "{{ 'enabled' if admin_enabled.stdout.strip() == 'True' else 'disabled' }}"
          audit_status: "{{ 'FAIL' if admin_enabled.stdout.strip() == 'True' else 'PASS' }}"
          severity: "HIGH"
          mitigation_advice: "Il est recommandé de désactiver le compte Administrateur par défaut et d'utiliser des comptes nominatifs avec droits maîtrisés (LAPS pour les mots de passe locaux)."
          mitigation_cmd: "Disable-LocalUser -Name 'Administrator'"

    - name: Check Guest account
      win_shell: '(Get-LocalUser -Name "Guest").Enabled'
      register: guest_enabled

    - name: Record Guest account status
      debug:
        msg:
          task: "Guest account"
          msg: "{{ 'enabled' if guest_enabled.stdout.strip() == 'True' else 'disabled' }}"
          audit_status: "{{ 'FAIL' if guest_enabled.stdout.strip() == 'True' else 'PASS' }}"
          severity: "HIGH"
          mitigation_advice: "Il est recommandé de désactiver le compte Guest par défaut si non utilisé."
          mitigation_cmd: "Disable-LocalUser -Name 'Guest'"

    # --- Password policy ---
    - name: Check minimum password length
      win_shell: '(net accounts) -match "Minimum password length"'
      register: password_length

    - name: Record password policy
      debug:
        msg:
          task: "Password minimum length"
          msg: "{{ 'FAIL (<12)' if (password_length.stdout.split(':')[-1] | int) < 12 else 'PASS (>=12)' }}"
          audit_status: "{{ 'FAIL' if (password_length.stdout.split(':')[-1] | int) < 12 else 'PASS' }}"
          severity: "HIGH"
          mitigation_advice: "Augmentez la longueur minimale des mots de passe (recommandation: 12+ pour utilisateurs, 15+ pour comptes privilégiés)."
          mitigation_cmd: "net accounts /minpwlen:12"

    # --- LAPS installation ---
    - name: Check LAPS installation
      win_shell: |
        if ((Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\LAPS") -or
            (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions\{D76B9641-3288-4f75-942D-087DE603E36B}")) {
          Write-Output "True"
        } else { 
          Write-Output "False" 
        }
      register: laps_present

    - name: Record LAPS status
      debug:
        msg:
          task: "LAPS installation"
          msg: "{{ 'installed' if laps_present.stdout.strip() == 'True' else 'not installed' }}"
          audit_status: "{{ 'PASS' if laps_present.stdout.strip() == 'True' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Installer et déployer Microsoft LAPS pour gérer automatiquement les mots de passe des comptes administrateurs locaux."
          mitigation_cmd: "Install-Module -Name LAPS -Force"

    # --- UAC ---
    - name: Check UAC (EnableLUA)
      win_shell: '(Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "EnableLUA").EnableLUA'
      register: uac

    - name: Record UAC status
      debug:
        msg:
          task: "UAC (EnableLUA)"
          msg: "{{ 'enabled' if uac.stdout.strip() == '1' else 'disabled' }}"
          audit_status: "{{ 'PASS' if uac.stdout.strip() == '1' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Activer l'UAC pour réduire la surface d'exécution avec privilèges élevés."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System' -Name EnableLUA -Value 1"

    # --- SMBv1 ---
    - name: Check SMBv1
      win_shell: '(Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol).State'
      register: smb1

    - name: Record SMBv1 status
      debug:
        msg:
          task: "SMBv1"
          msg: "{{ 'enabled' if smb1.stdout.strip() == 'Enabled' else 'disabled' }}"
          audit_status: "{{ 'FAIL' if smb1.stdout.strip() == 'Enabled' else 'PASS' }}"
          severity: "CRITICAL"
          mitigation_advice: "Désactiver SMBv1, obsolète et vulnérable."
          mitigation_cmd: "Disable-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -NoRestart"

    # --- SMB signing ---
    - name: Check SMB server signing
      win_shell: '(Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Services\LanmanServer\Parameters" -Name "requiresecuritysignature").requiresecuritysignature'
      register: smb_sig

    - name: Record SMB signing status
      debug:
        msg:
          task: "SMB signing"
          msg: "{{ 'required' if smb_sig.stdout.strip() == '1' else 'not required' }}"
          audit_status: "{{ 'PASS' if smb_sig.stdout.strip() == '1' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Forcer la signature SMB côté serveur pour se protéger contre le relay NTLM."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters' -Name requiresecuritysignature -Value 1"

    # --- RDP Security ---
    - name: Check RDP SecurityLayer
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "SecurityLayer").SecurityLayer'
      register: rdp_sec

    - name: Record RDP SecurityLayer
      debug:
        msg:
          task: "RDP SecurityLayer"
          msg: "{{ 'TLS (2)' if rdp_sec.stdout.strip() == '2' else 'not TLS' }}"
          audit_status: "{{ 'PASS' if rdp_sec.stdout.strip() == '2' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Configurer SecurityLayer à 2 pour forcer TLS pour RDP."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -Name SecurityLayer -Value 2"

    - name: Check RDP NLA
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "UserAuthentication").UserAuthentication'
      register: rdp_nla

    - name: Record RDP NLA status
      debug:
        msg:
          task: "RDP NLA"
          msg: "{{ 'enabled' if rdp_nla.stdout.strip() == '1' else 'not enabled' }}"
          audit_status: "{{ 'PASS' if rdp_nla.stdout.strip() == '1' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Activer NLA pour protéger le service RDP."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -Name UserAuthentication -Value 1"

    # --- Potentially dangerous services ---
    - name: Check dangerous services
      win_shell: |
        $services = @("WinHttpAutoProxySvc","WebClient","Spooler")
        foreach ($svc in $services) {
          try {
            $s = Get-Service -Name $svc -ErrorAction Stop
            if ($s.Status -eq "Running") { Write-Output "$svc:Running" }
            else { Write-Output "$svc:Stopped" }
          } catch { Write-Output "$svc:NotInstalled" }
        }
      register: dangerous_services

    - name: Record dangerous services
      debug:
        msg: >
          {% set item_val = item %}
          { "task": "Service {{ item_val.split(':')[0] }}",
            "msg": "{{ item_val }}",
            "audit_status": "{{ 'FAIL' if ':Running' in item_val else 'PASS' if ':Stopped' in item_val else 'INFO' }}",
            "severity": "MEDIUM",
            "mitigation_advice": "Évaluer la nécessité du service et désactiver s'il n'est pas requis sur ce rôle serveur.",
            "mitigation_cmd": "Set-Service -Name '{{ item_val.split(':')[0] }}' -StartupType Disabled; Stop-Service -Name '{{ item_val.split(':')[0] }}'"
          }
      loop: "{{ dangerous_services.stdout_lines }}"

    # --- Firewall ---
    - name: Check Windows Firewall profiles
      win_shell: 'Get-NetFirewallProfile | ForEach-Object { "$($_.Name):$($_.Enabled)" }'
      register: firewall_profiles

    - name: Record firewall profiles
      debug:
        msg:
          task: "Firewall profile"
          msg: "{{ item }}"
          audit_status: "{{ 'PASS' if ':True' in item else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Activer le pare-feu pour le profil concerné et vérifier les règles."
          mitigation_cmd: "Set-NetFirewallProfile -Profile {{ item.split(':')[0] }} -Enabled True"
      loop: "{{ firewall_profiles.stdout_lines }}"

    # --- LLMNR ---
    - name: Check LLMNR
      win_shell: '(Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient" -Name "EnableMulticast").EnableMulticast'
      register: llmnr

    - name: Record LLMNR status
      debug:
        msg:
          task: "LLMNR"
          msg: "{{ 'disabled' if llmnr.stdout.strip() == '0' else 'enabled' }}"
          audit_status: "{{ 'PASS' if llmnr.stdout.strip() == '0' else 'FAIL' }}"
          severity: "MEDIUM"
          mitigation_advice: "Afin de se protéger de certaines attaques par Man-In-The-Middle, les protocoles de résolution de noms NBT-NS et LLMNR doivent être désactivés. LLMNR : la clé SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient\\EnableMulticast doit être présente et définie à 0"
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\DNSClient' -Name EnableMulticast -Value 0"

    # --- Audit Policy ---
    - name: Check logon/logoff audit policy
      win_shell: 'auditpol /get /category:"Logon/Logoff" | Select-String "Success and Failure"'
      register: audit_policy

    - name: Record audit policy
      debug:
        msg:
          task: "Audit logon/logoff"
          msg: "{{ 'configured' if audit_policy.stdout != '' else 'not configured' }}"
          audit_status: "{{ 'PASS' if audit_policy.stdout != '' else 'FAIL' }}"
          severity: "MEDIUM"
          mitigation_advice: "Configurer l'audit pour succès et échecs sur logon/logoff via GPO."
          mitigation_cmd: "auditpol /set /category:'Logon/Logoff' /success:enable /failure:enable"

    # --- Security log size ---
    - name: Check security log max size
      win_shell: '(Get-WinEvent -ListLog Security).MaximumSizeInBytes / 1MB'
      register: sec_log_size

    - name: Record security log size
      debug:
        msg:
          task: "Security log size"
          msg: "{{ '>=1GB' if sec_log_size.stdout|int >= 1024 else '<1GB' }}"
          audit_status: "{{ 'PASS' if sec_log_size.stdout|int >= 1024 else 'WARNING' }}"
          severity: "LOW"
          mitigation_advice: "Augmenter la taille du journal de sécurité pour éviter la perte d'événements."
          mitigation_cmd: "wevtutil sl Security /ms:1073741824"

    # --- Sysmon service ---
    - name: Check Sysmon service
      win_shell: |
        try {
          Get-Service -Name "Sysmon" -ErrorAction Stop
          Write-Output "installed"
        } catch {
          Write-Output "not installed"
        }
      register: sysmon_status

    - name: Record Sysmon status
      debug:
        msg:
          task: "Sysmon service"
          msg: "{{ 'installed' if sysmon_status.stdout.strip() == 'installed' else 'not installed' }}"
          audit_status: "{{ 'PASS' if sysmon_status.stdout.strip() == 'installed' else 'INFO' }}"
          severity: "INFO"
          mitigation_advice: "Installer Sysmon pour une meilleure journalisation si nécessaire."
          mitigation_cmd: "sysmon64.exe -accepteula -i sysmonconfig.xml"

    # --- BLOC 1 : Protection des identifiants (Credential Guard / LSASS) ---
    - name: Check LSASS RunAsPPL
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name "RunAsPPL" -ErrorAction SilentlyContinue).RunAsPPL'
      register: lsass_ppl

    - name: Record LSASS Protection
      debug:
        msg:
          task: "LSASS RunAsPPL"
          msg: "{{ 'enabled' if lsass_ppl.stdout.strip() == '1' else 'disabled' }}"
          audit_status: "{{ 'PASS' if lsass_ppl.stdout.strip() == '1' else 'FAIL' }}"
          severity: "CRITICAL"
          mitigation_advice: "Activer la protection LSA pour empêcher l'injection de code (Mimikatz). RunAsPPL force LSASS à s'exécuter en mode Protected Process Light."
          mitigation_cmd: "New-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa' -Name RunAsPPL -Value 1 -PropertyType DWORD -Force"

    - name: Check WDigest (Cleartext Passwords)
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest" -Name "UseLogonCredential" -ErrorAction SilentlyContinue).UseLogonCredential'
      register: wdigest

    - name: Record WDigest status
      debug:
        msg:
          task: "WDigest (Cleartext Passwords)"
          msg: "{{ 'disabled' if wdigest.stdout.strip() == '0' else 'enabled/default' }}"
          audit_status: "{{ 'PASS' if wdigest.stdout.strip() == '0' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Désactiver WDigest pour éviter le stockage de mots de passe en clair en mémoire (attaques post-exploitation)."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest' -Name UseLogonCredential -Value 0"

    # --- BLOC 2 : NetBIOS over TCP/IP ---
    - name: Check NetBIOS NoNameReleaseOnDemand
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NetBT\Parameters" -Name "NoNameReleaseOnDemand" -ErrorAction SilentlyContinue).NoNameReleaseOnDemand'
      register: netbios_check

    - name: Record NetBIOS status
      debug:
        msg:
          task: "NetBIOS (NoNameReleaseOnDemand)"
          msg: "{{ 'restricted' if netbios_check.stdout.strip() == '1' else 'default' }}"
          audit_status: "{{ 'PASS' if netbios_check.stdout.strip() == '1' else 'FAIL' }}"
          severity: "MEDIUM"
          mitigation_advice: "Afin de se protéger de certaines attaques par Man-In-The-Middle, les protocoles de résolution de noms NBT-NS et LLMNR doivent être désactivés. NETBIOS : la clé System\\CurrentControlSet\\Services\\Netbt\\Parameters\\NoNameReleaseOnDemand doit être définie à 1"
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters' -Name NoNameReleaseOnDemand -Value 1"

    # --- BLOC 3 : Windows Defender & AppLocker ---
    - name: Check Windows Defender RealTime Protection
      win_shell: '(Get-MpPreference).DisableRealtimeMonitoring'
      register: defender_rt

    - name: Record Defender RealTime status
      debug:
        msg:
          task: "Defender RealTime Protection"
          msg: "{{ 'enabled' if defender_rt.stdout.strip() == 'False' else 'disabled' }}"
          audit_status: "{{ 'PASS' if defender_rt.stdout.strip() == 'False' else 'FAIL' }}"
          severity: "CRITICAL"
          mitigation_advice: "Activer la protection en temps réel de Windows Defender pour détecter les malwares à l'exécution."
          mitigation_cmd: "Set-MpPreference -DisableRealtimeMonitoring $false"

    - name: Check AppLocker Effective Policy
      win_shell: '(Get-AppLockerPolicy -Effective -ErrorAction SilentlyContinue).RuleCollections.Count'
      register: applocker_rules

    - name: Record AppLocker status
      debug:
        msg:
          task: "AppLocker Rules"
          msg: "{{ 'Active (' + (applocker_rules.stdout.strip() | default('0')) + ' collections)' if (applocker_rules.stdout.strip() | default('0')) | int > 0 else 'No rules enforced' }}"
          audit_status: "{{ 'PASS' if (applocker_rules.stdout.strip() | default('0')) | int > 0 else 'WARNING' }}"
          severity: "HIGH"
          mitigation_advice: "Définir des règles AppLocker pour contrôler l'exécution des binaires et scripts (whitelist par défaut)."
          mitigation_cmd: "New-AppLockerPolicy -RuleType Exe,Msi,Script,Dll -User Everyone -RuleNamePrefix 'Default' -Force"

    # --- BLOC 4 : Cache des sessions (Cached Logons) ---
    - name: Check Cached Logons Count
      win_shell: '(Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "CachedLogonsCount" -ErrorAction SilentlyContinue).CachedLogonsCount'
      register: cached_logons

    - name: Record Cached Logons
      debug:
        msg:
          task: "Cached Logons Count"
          msg: "{{ cached_logons.stdout.strip() | default('not found') }}"
          audit_status: "{{ 'PASS' if (cached_logons.stdout.strip() | default('999') | int) <= 2 else 'FAIL' }}"
          severity: "MEDIUM"
          mitigation_advice: "Réduire le nombre de sessions en cache (0-2) pour limiter l'extraction de hash MSCache2 par les attaquants en cas de compromission offline."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' -Name CachedLogonsCount -Value 1"

    # --- BLOC 5 : WinRM & RDP - Administration à distance sécurisée ---
    - name: Check WinRM Basic Auth & Encryption
      win_shell: |
        $basic = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WinRM\Service" -Name "AllowBasic" -ErrorAction SilentlyContinue).AllowBasic
        $unenc = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WinRM\Service" -Name "AllowUnencryptedTraffic" -ErrorAction SilentlyContinue).AllowUnencryptedTraffic
        if ($basic -eq 0 -and $unenc -eq 0) { Write-Output "Secure" } else { Write-Output "Insecure" }
      register: winrm_sec

    - name: Record WinRM Status
      debug:
        msg:
          task: "WinRM Hardening"
          msg: "{{ winrm_sec.stdout.strip() }}"
          audit_status: "{{ 'PASS' if winrm_sec.stdout.strip() == 'Secure' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Désactiver l'authentification Basic et le trafic non chiffré pour WinRM pour éviter les attaques Man-In-The-Middle."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WinRM\\Service' -Name AllowBasic -Value 0; Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WinRM\\Service' -Name AllowUnencryptedTraffic -Value 0"

    - name: Check RDP MinEncryptionLevel
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name "MinEncryptionLevel" -ErrorAction SilentlyContinue).MinEncryptionLevel'
      register: rdp_enc

    - name: Record RDP Encryption Level
      debug:
        msg:
          task: "RDP Encryption Level"
          msg: "{{ 'High/FIPS' if (rdp_enc.stdout.strip() | default('0') | int) >= 3 else 'Low' }}"
          audit_status: "{{ 'PASS' if (rdp_enc.stdout.strip() | default('0') | int) >= 3 else 'WARNING' }}"
          severity: "MEDIUM"
          mitigation_advice: "Régler le niveau de chiffrement RDP à 3 (High) ou 4 (FIPS) pour protéger les sessions RDP."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp' -Name MinEncryptionLevel -Value 3"

    # --- BLOC 6 : Protection contre les Exploits (ASR & Controlled Folder Access) ---
    - name: Check ASR Rules Status
      win_shell: '(Get-MpPreference).AttackSurfaceReductionRules_Actions'
      register: asr_rules

    - name: Record ASR Status
      debug:
        msg:
          task: "ASR Rules (Exploit Guard)"
          msg: "{{ 'Configured' if (asr_rules.stdout.strip() | default('')) != '' and ('1' in asr_rules.stdout or '2' in asr_rules.stdout) else 'Not Configured' }}"
          audit_status: "{{ 'PASS' if (asr_rules.stdout.strip() | default('')) != '' and ('1' in asr_rules.stdout or '2' in asr_rules.stdout) else 'WARNING' }}"
          severity: "MEDIUM"
          mitigation_advice: "Activer les règles de réduction de surface d'attaque (ASR) via GPO ou PowerShell pour bloquer les techniques d'exploitation courantes."
          mitigation_cmd: "Set-MpPreference -AttackSurfaceReductionRules_Actions Enabled"

    - name: Check Controlled Folder Access
      win_shell: '(Get-MpPreference).EnableControlledFolderAccess'
      register: folder_access

    - name: Record Ransomware Protection
      debug:
        msg:
          task: "Controlled Folder Access"
          msg: "{{ 'Enabled' if folder_access.stdout.strip() == '1' else 'Disabled' }}"
          audit_status: "{{ 'PASS' if folder_access.stdout.strip() == '1' else 'INFO' }}"
          severity: "MEDIUM"
          mitigation_advice: "Activer la protection des dossiers contrôlés pour bloquer les attaques ransomware et les modifications non autorisées."
          mitigation_cmd: "Set-MpPreference -EnableControlledFolderAccess Enabled"

    # --- BLOC 7 : Sécurité Physique et Périphériques (BitLocker & USB) ---
    - name: Check USB AutoRun (NoDriveTypeAutoRun)
      win_shell: |
        $val = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer" -Name "NoDriveTypeAutoRun" -ErrorAction SilentlyContinue).NoDriveTypeAutoRun
        if ($val -eq 255 -or $val -eq 221) { Write-Output "Secure" } else { Write-Output "Insecure" }
      register: autorun_check

    - name: Record USB AutoRun
      debug:
        msg:
          task: "USB AutoRun"
          msg: "{{ autorun_check.stdout.strip() }}"
          audit_status: "{{ 'PASS' if autorun_check.stdout.strip() == 'Secure' else 'FAIL' }}"
          severity: "MEDIUM"
          mitigation_advice: "Désactiver l'exécution automatique pour tous les lecteurs pour prévenir les attaques par USB malveillants."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer' -Name NoDriveTypeAutoRun -Value 255"

    - name: Check BitLocker on C drive
      win_shell: |
        try {
          $status = (Get-BitLockerVolume -MountPoint "C:" -ErrorAction Stop).ProtectionStatus
          Write-Output $status
        } catch {
          Write-Output "Not installed"
        }
      register: bitlocker_status

    - name: Record BitLocker Status
      debug:
        msg:
          task: "BitLocker C:"
          msg: "{{ 'On' if bitlocker_status.stdout.strip() == 'On' else 'Off/Not installed' }}"
          audit_status: "{{ 'PASS' if bitlocker_status.stdout.strip() == 'On' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Activer BitLocker sur le disque système pour chiffrer les données au repos et protéger contre le vol de données physiques."
          mitigation_cmd: "Enable-BitLocker -MountPoint 'C:' -EncryptionMethod Aes256"

    # --- BLOC 8 : Contrôle des Scripts (PowerShell Language Mode) ---
    - name: Check PowerShell Language Mode
      win_shell: '$ExecutionContext.SessionState.LanguageMode'
      register: ps_mode

    - name: Record PowerShell Language Mode
      debug:
        msg:
          task: "PowerShell Language Mode"
          msg: "{{ ps_mode.stdout.strip() }}"
          audit_status: "{{ 'PASS' if ps_mode.stdout.strip() == 'ConstrainedLanguage' else 'INFO' }}"
          severity: "LOW"
          mitigation_advice: "Envisager le mode ConstrainedLanguage pour les utilisateurs standards via AppLocker ou WDAC pour bloquer les scripts malveillants avancés."
          mitigation_cmd: "# Configuration via AppLocker ou WDAC - ne peut pas être changé directement"

    # --- BLOC 9 : SMB Client Signing (Protection côté client) ---
    - name: Check SMB Client Signing
      win_shell: '(Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Services\LanmanWorkstation\Parameters" -Name "RequireSecuritySignature" -ErrorAction SilentlyContinue).RequireSecuritySignature'
      register: smb_client_sig

    - name: Record SMB Client Signing
      debug:
        msg:
          task: "SMB Client Signing"
          msg: "{{ 'Required' if smb_client_sig.stdout.strip() == '1' else 'Not Required' }}"
          audit_status: "{{ 'PASS' if smb_client_sig.stdout.strip() == '1' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Forcer la signature SMB côté client (LanmanWorkstation) pour empêcher que la machine ne serve de relais dans les attaques de replay/relay NTLM."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters' -Name RequireSecuritySignature -Value 1"

    # --- BLOC 10 : Journalisation Avancée PowerShell (Script Block Logging) ---
    - name: Check PowerShell Script Block Logging
      win_shell: '(Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -Name "EnableScriptBlockLogging" -ErrorAction SilentlyContinue).EnableScriptBlockLogging'
      register: ps_logging

    - name: Record PowerShell Logging
      debug:
        msg:
          task: "PowerShell Script Block Logging"
          msg: "{{ 'Enabled' if ps_logging.stdout.strip() == '1' else 'Disabled' }}"
          audit_status: "{{ 'PASS' if ps_logging.stdout.strip() == '1' else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Activer la journalisation des blocs de scripts PowerShell pour auditer les commandes exécutées, même offusquées."
          mitigation_cmd: "New-Item -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging' -Force; Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptBlockLogging' -Name EnableScriptBlockLogging -Value 1"

    # --- BLOC 11 : Sécurité WSUS (Windows Update) ---
    - name: Check WSUS Server HTTPS
      win_shell: |
        $wuserver = (Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows\WindowsUpdate" -Name "WUServer" -ErrorAction SilentlyContinue).WUServer
        if ($null -eq $wuserver) { 
            Write-Output "Direct Microsoft Update" 
        } elseif ($wuserver -like "https://*") { 
            Write-Output "Secure (HTTPS)" 
        } else { 
            Write-Output "Insecure (HTTP)" 
        }
      register: wsus_check
      ignore_errors: yes

    - name: Record WSUS Security
      debug:
        msg:
          task: "WSUS Configuration"
          msg: "{{ wsus_check.stdout.strip() }}"
          audit_status: "{{ 'FAIL' if 'Insecure' in wsus_check.stdout else 'PASS' }}"
          severity: "HIGH"
          mitigation_advice: "Si un serveur WSUS est utilisé, il DOIT être configuré en HTTPS pour éviter l'injection de fausses mises à jour."
          mitigation_cmd: "Configurer le serveur WSUS pour utiliser SSL/TLS et mettre à jour la GPO."

    # --- BLOC 12 : Virtualization Based Security (VBS) ---
    - name: Check VBS Status
      win_shell: |
        try {
            $vbs = (Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard -ErrorAction Stop).SecurityServicesRunning
            if ($vbs -contains 1) { Write-Output "Running" } else { Write-Output "Not Running" }
        } catch { Write-Output "Not Compatible/Not Found" }
      register: vbs_status
      ignore_errors: yes

    - name: Record VBS Status
      debug:
        msg:
          task: "Virtualization Based Security (Credential Guard)"
          msg: "{{ vbs_status.stdout.strip() }}"
          audit_status: "{{ 'PASS' if vbs_status.stdout.strip() == 'Running' else 'INFO' }}"
          severity: "MEDIUM"
          mitigation_advice: "Activer VBS et Credential Guard si le matériel le supporte (nécessite CPU avec virtualisation + TPM)."
          mitigation_cmd: "Activer via GPO: Configuration Ordinateur > Système > Device Guard > Activer la sécurité basée sur la virtualisation."

    # --- BLOC 13 : Local Admin Group Members ---
    - name: Audit Local Admin Group Members
      win_shell: |
        try {
            Get-LocalGroupMember -Group 'Administrators' -ErrorAction Stop | Select-Object -ExpandProperty Name
        } catch {
            try {
                Get-LocalGroupMember -Group 'Administrateurs' -ErrorAction Stop | Select-Object -ExpandProperty Name
            } catch {
                Write-Output "Error: Unable to query local administrators group"
            }
        }
      register: admin_members
      ignore_errors: yes

    - name: Record Local Admins
      debug:
        msg:
          task: "Local Admin Group Members"
          msg: "{{ admin_members.stdout }}"
          audit_status: "PASS"
          severity: "MEDIUM"
          mitigation_advice: "Auditer régulièrement les membres du groupe Administrateurs et supprimer les comptes inutilisés. Utiliser LAPS pour gérer les comptes locaux."
          mitigation_cmd: "Get-LocalGroupMember -Group 'Administrateurs'"

    # --- BLOC 14 : IPv6 Status Check ---
    - name: Check IPv6 Status
      win_shell: '(Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip6\Parameters" -Name "DisabledComponents" -ErrorAction SilentlyContinue).DisabledComponents'
      register: ipv6_status

    - name: Record IPv6 Status
      debug:
        msg:
          task: "IPv6 Status"
          msg: "{{ 'Disabled' if ipv6_status.stdout.strip() == '255' else 'Enabled (Default)' }}"
          audit_status: "{{ 'PASS' if ipv6_status.stdout.strip() == '255' else 'INFO' }}"
          severity: "LOW"
          mitigation_advice: "Si IPv6 n'est pas utilisé, le désactiver via la clé DisabledComponents (valeur 0xFF/255) pour réduire la surface d'attaque."
          mitigation_cmd: "Set-ItemProperty -Path 'HKLM:\\SYSTEM\\CurrentControlSet\\Services\\Tcpip6\\Parameters' -Name DisabledComponents -Value 255"

    # --- BLOC 15 : Windows Event Forwarding (WEF) ---
    - name: Check WEF Subscription
      win_shell: '(Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\EventLog\EventForwarding\SubscriptionManager" -Name "1" -ErrorAction SilentlyContinue)."1"'
      register: wef_check

    - name: Record WEF Status
      debug:
        msg:
          task: "Windows Event Forwarding (WEF)"
          msg: "{{ 'Configured' if wef_check.stdout.strip() != '' else 'Not Configured' }}"
          audit_status: "{{ 'PASS' if wef_check.stdout.strip() != '' else 'FAIL' }}"
          severity: "MEDIUM"
          mitigation_advice: "Configurer WEF pour centraliser les journaux sur un serveur de logs centralisé (SIEM). Cela permet une meilleure détection d'incidents et conformité."
          mitigation_cmd: "# Configuration via GPO ou WEF Subscription Manager"

    # --- Potentially dangerous services (Updated list) ---
    - name: Check dangerous services
      win_shell: |
        $services = @("WinHttpAutoProxySvc", "WebClient", "Spooler", "DiagTrack", "Dmwappushservice", "XblAuthManager", "XblGameSave", "XboxNetApiSvc")
        foreach ($svc in $services) {
          try {
            $s = Get-Service -Name $svc -ErrorAction Stop
            if ($s.Status -eq "Running") { Write-Output "$svc`:Running" }
            else { Write-Output "$svc`:Stopped" }
          } catch { Write-Output "$svc`:NotInstalled" }
        }
      register: dangerous_services

    # --- BLOC 16 : Inventaire Logiciel (Vulnerable Software) ---
    - name: Check installed software versions
      win_shell: |
        $apps = @()
        # Récupérer les apps x64
        Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue | 
          Where-Object { $_.DisplayName } | ForEach-Object { $apps += $_.DisplayName + " (v" + $_.DisplayVersion + ")" }
        # Récupérer les apps x86
        Get-ItemProperty "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue | 
          Where-Object { $_.DisplayName } | ForEach-Object { $apps += $_.DisplayName + " (v" + $_.DisplayVersion + ")" }
        if ($apps.Count -gt 0) { 
          $apps | Sort-Object -Unique | ForEach-Object { Write-Output $_ }
        } else { 
          Write-Output "No software detected" 
        }
      register: installed_software

    - name: Record Software Inventory
      debug:
        msg:
          task: "Installed Software Inventory"
          msg: "{{ installed_software.stdout if installed_software.stdout.strip() else 'No software found' }}"
          audit_status: "INFO"
          severity: "MEDIUM"
          mitigation_advice: "Audit complet de tous les logiciels installés. Vérifier les versions des logiciels critiques (Java, Adobe, navigateurs, etc.). Maintenir à jour et appliquer les patches rapidement, particulièrement pour les logiciels côté client souvent exploités."
          mitigation_cmd: "# Mettre à jour via Windows Update, WSUS ou les outils spécifiques des éditeurs"

    # --- BLOC 17 : Permissions sur les Services Critiques ---
    - name: Check service registry permissions
      win_shell: |
        $criticalServices = @("BITS", "Spooler", "UpdateOrchestrator", "WinRM", "lsass")
        foreach ($svc in $criticalServices) {
          try {
            $regPath = "HKLM:\System\CurrentControlSet\Services\$svc"
            $acl = Get-Acl -Path $regPath -ErrorAction Stop
            # Vérifier si des utilisateurs standard ont des droits écriture
            $hasRisk = $false
            foreach ($access in $acl.Access) {
              if ($access.IdentityReference -like "*Users*" -and ($access.FileSystemRights -match "Write|Modify|FullControl")) {
                $hasRisk = $true
                Write-Output "$svc`:RISKY_PERMISSIONS"
                break
              }
            }
            if (-not $hasRisk) { Write-Output "$svc`:Secure" }
          } catch { Write-Output "$svc`:Error/NotFound" }
        }
      register: service_perms

    - name: Record Service Permissions
      debug:
        msg:
          task: "Service Registry Permissions"
          msg: "{{ service_perms.stdout }}"
          audit_status: "{{ 'FAIL' if 'RISKY_PERMISSIONS' in service_perms.stdout else 'PASS' }}"
          severity: "HIGH"
          mitigation_advice: "Les services critiques ne doivent être modifiables que par SYSTEM et Administrateurs. Supprimer les droits Write/Modify pour le groupe Users ou Utilisateurs authentifiés sur les clés de registre des services."
          mitigation_cmd: "# Utiliser icacls ou Set-Acl pour corriger les permissions. Exemple: icacls 'HKLM\\SYSTEM\\CurrentControlSet\\Services\\Spooler' /grant:r 'SYSTEM:(F)' /grant:r 'Admins:(F)' /remove 'Users'"

    # --- BLOC 18 : Stockage des LM Hashes ---
    - name: Check NoLMHash Policy
      win_shell: |
        try {
          $output = secedit /export /cfg $env:TEMP\secpol.txt
          $lmhash = (Select-String -Path "$env:TEMP\secpol.txt" -Pattern "NoLMHash" | Select-Object -First 1).ToString()
          if ($lmhash -match "NoLMHash\s*=\s*1") {
            Write-Output "NoLMHash=1:Secure"
          } elseif ($lmhash -match "NoLMHash") {
            Write-Output "NoLMHash=0:Vulnerable"
          } else {
            Write-Output "NoLMHash=0:Default(Vulnerable)"
          }
          Remove-Item "$env:TEMP\secpol.txt" -Force -ErrorAction SilentlyContinue
        } catch {
          Write-Output "Error/Unable to check"
        }
      register: lmhash_policy

    - name: Record NoLMHash Status
      debug:
        msg:
          task: "LMHASH Disable (NoLMHash)"
          msg: "{{ lmhash_policy.stdout.strip() }}"
          audit_status: "{{ 'PASS' if 'Secure' in lmhash_policy.stdout else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Activer NoLMHash pour empêcher le stockage des empreintes LM dans la base SAM. Les hashes LM sont vulnérables aux attaques par force brute. La valeur 'aad3b435b51404eeaad3b435b51404ee' indique un mot de passe vide ou l'absence de stockage LM."
          mitigation_cmd: "secedit /export /cfg C:\\secpol.txt; (Get-Content C:\\secpol.txt) -replace 'NoLMHash = 0', 'NoLMHash = 1' | Set-Content C:\\secpol.txt; secedit /configure /db C:\\Windows\\security\\local.sdb /cfg C:\\secpol.txt /overwrite /quiet"

    # --- BLOC 19 : Smart App Control ---
    - name: Check Smart App Control Status
      win_shell: |
        try {
          $sacPolicy = (Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\CI\Policy" -Name "VerifiedAndReputablePolicyState" -ErrorAction SilentlyContinue).VerifiedAndReputablePolicyState
          if ($null -eq $sacPolicy) {
            Write-Output "NotPresent:Not Installed/Not Compatible"
          } elseif ($sacPolicy -eq 0) {
            Write-Output "Off:0"
          } elseif ($sacPolicy -eq 1) {
            Write-Output "On:1"
          } elseif ($sacPolicy -eq 2) {
            Write-Output "EvaluationMode:2"
          } else {
            Write-Output "Unknown:$sacPolicy"
          }
        } catch {
          Write-Output "Error/Unable to check"
        }
      register: sac_status

    - name: Record Smart App Control Status
      debug:
        msg:
          task: "Smart App Control"
          msg: "{{ sac_status.stdout.strip() }}"
          audit_status: "{{ 'PASS' if ('On:1' in sac_status.stdout or 'EvaluationMode:2' in sac_status.stdout) else 'INFO' }}"
          severity: "MEDIUM"
          mitigation_advice: "Smart App Control protège le système en contrôlant l'exécution des applications. Disponible sur Windows 11 (version 22572+) avec une installation propre en Amérique du Nord ou Europe. 0=Désactivé, 1=Activé, 2=Mode évaluation."
          mitigation_cmd: "Smart App Control ne peut être activé que lors d'une installation Windows propre. Accédez à Paramètres > Confidentialité et sécurité > App Security Management"

    # --- BLOC 20 : Mot de passe BIOS/UEFI (Recommandation) ---
    - name: Check BIOS Password Recommendation
      win_shell: |
        Write-Output "BIOSPassword:ManualCheck:Firmware-level security cannot be audited via Windows. Please verify manually in BIOS/UEFI settings."
      register: bios_check

    - name: Record BIOS Password Recommendation
      debug:
        msg:
          task: "BIOS/UEFI Password"
          msg: "Manual verification required"
          audit_status: "INFO"
          severity: "HIGH"
          mitigation_advice: "Recommandation pour le mot de passe BIOS (pas de check possible mais message à afficher)."
          mitigation_cmd: "Configurer un mot de passe BIOS/UEFI dans les paramètres du firmware"

    # --- BLOC 21 : Niveau des Mises à Jour Windows ---
    - name: Check Windows Update Level
      win_shell: |
        try {
          $osVersion = [System.Environment]::OSVersion.VersionString
          $winver = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"
          $buildNumber = $winver.CurrentBuildNumber
          $releaseId = $winver.ReleaseId
          $displayVersion = $winver.DisplayVersion
          
          # Déterminer le statut basé sur la version
          if ([int]$buildNumber -ge 22621) {
            Write-Output "Windows11:Build$buildNumber:Current/Latest"
          } elseif ([int]$buildNumber -ge 22000) {
            Write-Output "Windows11:Build$buildNumber:Outdated"
          } elseif ([int]$buildNumber -ge 19045) {
            Write-Output "Windows10:Build$buildNumber:OutOfSupport"
          } else {
            Write-Output "Windows-Older:Build$buildNumber:CriticallyOutdated"
          }
        } catch {
          Write-Output "Error:Unable to determine Windows version"
        }
      register: windows_update

    - name: Record Windows Update Level
      debug:
        msg:
          task: "Windows Update Level"
          msg: "{{ windows_update.stdout.strip() }}"
          audit_status: "{{ 'PASS' if 'Current/Latest' in windows_update.stdout or 'Build' in windows_update.stdout else 'FAIL' }}"
          severity: "CRITICAL"
          mitigation_advice: "Maintenir le système à jour avec les derniers patches de sécurité est essentiel. Windows 11 Build 22621+ est considéré comme à jour. Windows 10 a atteint la fin du support (EOS: 14 octobre 2025). Les versions antérieures ne reçoivent plus de mises à jour de sécurité et présentent un risque critique. Appliquez immédiatement tous les patchs disponibles via Windows Update."
          mitigation_cmd: "Aller à Paramètres > Mise à jour et sécurité > Mises à jour Windows > Vérifier les mises à jour. Ou utiliser: Install-Module -Name PSWindowsUpdate -Force; Get-WindowsUpdate -Install -AcceptAll"

    # --- BLOC 22 : Windows Hello for Business (MFA/MWA) ---
    - name: Check Windows Hello for Business - GPO
      win_shell: |
        try {
          $whfbGPO = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\PassportForWork" -Name "Enabled" -ErrorAction SilentlyContinue).Enabled
          $whfbCSP = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Policies\PassportForWork" -Name "UsePassportForWork" -ErrorAction SilentlyContinue).UsePassportForWork
          
          if ($whfbGPO -eq 1) {
            Write-Output "Enabled:GPO"
          } elseif ($whfbCSP -eq 1) {
            Write-Output "Enabled:CSP"
          } else {
            Write-Output "Disabled:NotConfigured"
          }
        } catch {
          Write-Output "Error/Unable to check"
        }
      register: whfb_status

    - name: Record Windows Hello for Business Status
      debug:
        msg:
          task: "Windows Hello for Business"
          msg: "{{ whfb_status.stdout.strip() }}"
          audit_status: "{{ 'PASS' if 'Enabled' in whfb_status.stdout else 'FAIL' }}"
          severity: "HIGH"
          mitigation_advice: "Windows Hello for Business offre une authentification multi-facteur (MFA) basée sur la biométrie ou le PIN, renforçant considérablement la sécurité des accès. L'activation peut se faire via GPO (HKLM:\\SOFTWARE\\Policies\\Microsoft\\PassportForWork\\Enabled) ou CSP (HKLM:\\SOFTWARE\\Microsoft\\Policies\\PassportForWork\\UsePassportForWork). Cela remplace les mots de passe traditionnels par une authentification multi-facteurs."
          mitigation_cmd: "Configurer via GPO: Configuration Ordinateur > Politiques > Modèles d'administration > Système > Ouverture de session > Configurer Windows Hello for Business. Ou via CSP/Intune: Policies/Windows/PassportForWork"

    # --- BLOC 23 : Just Enough Administration (JEA) ---
    - name: Check JEA Configuration
      win_shell: |
        try {
          $jeaModules = @()
          $jeaPath = "$env:ProgramFiles\WindowsPowerShell\Modules\JEA"
          if (Test-Path $jeaPath) {
            Get-ChildItem -Path $jeaPath -Directory | ForEach-Object {
              $jeaModules += $_.Name
            }
          }
          
          # Vérifier les fichiers de configuration de session
          $sessionConfigs = Get-PSSessionConfiguration -ErrorAction SilentlyContinue
          $jeaConfigs = @()
          foreach ($config in $sessionConfigs) {
            $configPath = $config.ConfigFilePath
            if ($configPath -and (Test-Path $configPath)) {
              $content = Get-Content -Path $configPath -Raw
              if ($content -match "RoleDefinitions|VisibleCmdlets|ScriptBlockLogging") {
                $jeaConfigs += $config.Name
              }
            }
          }
          
          if ($jeaConfigs.Count -gt 0) {
            Write-Output "Configured:$($jeaConfigs -join ', ')"
          } elseif ($jeaModules.Count -gt 0) {
            Write-Output "Installed:$($jeaModules -join ', ')"
          } else {
            Write-Output "NotConfigured:NoJEA"
          }
        } catch {
          Write-Output "Error/Unable to check"
        }
      register: jea_status

    - name: Record JEA Configuration
      debug:
        msg:
          task: "Just Enough Administration (JEA)"
          msg: "{{ jea_status.stdout.strip() }}"
          audit_status: "{{ 'PASS' if 'Configured' in jea_status.stdout else 'INFO' }}"
          severity: "MEDIUM"
          mitigation_advice: "Just Enough Administration (JEA) limite les privilèges des comptes de service et administrateurs en ne loro accordant que les cmdlets PowerShell strictement nécessaires. Cela réduit les risques de compromission et de mouvements latéraux. Les rôles JEA doivent définir: RoleDefinitions, VisibleCmdlets, et ScriptBlockLogging pour auditer les actions."
          mitigation_cmd: "Configurer un endpoint JEA: New-PSRoleCapabilityFile -Path 'C:\\Program Files\\WindowsPowerShell\\Modules\\JEA\\RoleCapabilities\\LimitedRole.psrc' ; New-PSSessionConfigurationFile -RunAsVirtualAccount -RoleDefinitions @{LimitedRole='@{RoleCapabilityFiles=\"C:\\Program Files\\WindowsPowerShell\\Modules\\JEA\\RoleCapabilities\\LimitedRole.psrc\"}'}"

    # --- BLOC 24 : Permissions SMB vs NTFS ---
    - name: Check SMB Share Permissions vs NTFS
      win_shell: |
        try {
          $results = @()
          $shares = Get-SmbShare -ErrorAction SilentlyContinue | Where-Object {$_.Name -notmatch '^(IPC\$|ADMIN\$|C\$|D\$|E\$|PRINT\$)'}
          
          foreach ($share in $shares) {
            $sharePath = $share.Path
            $shareName = $share.Name
            try {
              $smbAccess = Get-SmbShareAccess -Name $shareName -ErrorAction SilentlyContinue | Select-Object -ExpandProperty AccountName
              $ntfsAccess = (Get-Acl -Path $sharePath -ErrorAction SilentlyContinue).Access | Select-Object -ExpandProperty IdentityReference
              
              $smbCount = @($smbAccess).Count
              $ntfsCount = @($ntfsAccess).Count
              
              if ($smbCount -gt $ntfsCount) {
                $results += "$shareName:MISMATCH(SMB>NTFS)"
              } else {
                $results += "$shareName:OK"
              }
            } catch {
              $results += "$shareName:Error"
            }
          }
          
          if ($results.Count -gt 0) {
            $results | ForEach-Object { Write-Output $_ }
          } else {
            Write-Output "NoSharesFound"
          }
        } catch {
          Write-Output "Error/Unable to check"
        }
      register: smb_ntfs_perms

    - name: Record SMB vs NTFS Permissions
      debug:
        msg:
          task: "SMB Share vs NTFS Permissions"
          msg: "{{ smb_ntfs_perms.stdout if smb_ntfs_perms.stdout.strip() else 'No shares to audit' }}"
          audit_status: "{{ 'FAIL' if 'MISMATCH' in smb_ntfs_perms.stdout else 'PASS' }}"
          severity: "HIGH"
          mitigation_advice: "Les permissions SMB et NTFS doivent être alignées. Les droits SMB ne sont restrictifs que s'ils sont plus permissifs que les droits NTFS. Une bonne pratique est: droits SMB restrictifs (Everyone: Read) + droits NTFS granulaires. Auditer régulièrement l'alignement pour éviter les escalades de privilèges."
          mitigation_cmd: "Vérifier: Get-SmbShare | foreach {Get-SmbShareAccess -Name $_.Name} et comparer avec: Get-Acl 'C:\\path\\to\\share' | Select-Object -ExpandProperty Access. Corriger en harmonisant les droits via Grant-SmbShareAccess et Set-Acl."

    # --- BLOC 25 : Services lancés au démarrage ---
    - name: List Startup Services
      win_shell: |
        try {
          $startupServices = @()
          # Via WMIC
          $wmicOutput = wmic startup get name,command /format:list 2>$null | Select-String "Name=|Command="
          
          # Via Get-Service (filtrer les services Auto/Boot)
          $services = Get-Service | Where-Object {$_.StartType -in @('Automatic', 'Boot')} | Select-Object -ExpandProperty Name
          
          if ($services.Count -gt 0) {
            foreach ($svc in $services) {
              $startupServices += $svc
            }
            Write-Output "StartupServices:Count=$($startupServices.Count)"
            $startupServices | ForEach-Object { Write-Output "- $_" }
          } else {
            Write-Output "NoStartupServices"
          }
        } catch {
          Write-Output "Error:Unable to list startup services"
        }
      register: startup_services

    - name: Record Startup Services
      debug:
        msg:
          task: "Startup Services Inventory"
          msg: "{{ startup_services.stdout if startup_services.stdout.strip() else 'Unable to retrieve' }}"
          audit_status: "INFO"
          severity: "MEDIUM"
          mitigation_advice: "Auditer les services lancés au démarrage est crucial pour identifier les entrées de persistance malveillante ou les services inutiles qui ralentissent le système. Désactiver les services non essentiels (DiagTrack, Spooler, etc.) et vérifier que les services Automatic n'ont pas été compromis. Chercher les services suspects ou les chemins d'exécution non standards."
          mitigation_cmd: "Lister via: Get-Service | Where-Object {$_.StartType -eq 'Automatic'} | Select-Object Name, DisplayName. Ou via WMIC: wmic startup get name,command. Désactiver un service: Set-Service -Name 'ServiceName' -StartupType Disabled"

    # --- BLOC 26 : Processus en cours d'exécution ---
    - name: List Running Processes
      win_shell: |
        try {
          $processes = @()
          $procList = Get-Process | Select-Object -Property Name, Id, ProcessName, @{Name='User';Expression={(Get-Process -Id $_.Id -ErrorAction SilentlyContinue | Select-Object @{Name='User';Expression={$_.UserName}}).User}} -ErrorAction SilentlyContinue
          
          if ($procList.Count -gt 0) {
            Write-Output "RunningProcesses:Count=$($procList.Count)"
            # Afficher les processus suspects (non-système)
            $suspiciousProcesses = $procList | Where-Object {$_.ProcessName -notmatch '^(svchost|lsass|csrss|System|explorer|dwm|winlogon|conhost|services|smss|SearchIndexer|UserOOBELocalService)$'}
            if ($suspiciousProcesses.Count -gt 0) {
              Write-Output "SuspiciousProcesses:$($suspiciousProcesses.Count)"
              $suspiciousProcesses | ForEach-Object { Write-Output "  $($_.Name) (PID:$($_.Id))" }
            } else {
              Write-Output "OnlySystemProcesses"
            }
          } else {
            Write-Output "Unable to retrieve processes"
          }
        } catch {
          Write-Output "Error:Unable to list running processes"
        }
      register: running_processes

    - name: Record Running Processes
      debug:
        msg:
          task: "Running Processes Inventory"
          msg: "{{ running_processes.stdout if running_processes.stdout.strip() else 'Unable to retrieve' }}"
          audit_status: "INFO"
          severity: "MEDIUM"
          mitigation_advice: "Auditer régulièrement les processus en cours d'exécution aide à détecter les malwares, les rootkits et les comportements suspects. Chercher les processus: avec des chemins non-standard, lancés par des comptes de faible privilège mais avec droits élevés, avec des noms similaires à des processus système (comme svcholt.exe au lieu de svchost.exe), ou lancés depuis des répertoires TEMP. Utiliser des outils comme Autoruns ou Process Monitor pour approfondir."
          mitigation_cmd: "Lister tous les processus: Get-Process. Avec détails utilisateur: Get-Process | Select-Object -Property Name, Id, @{Name='Owner';Expression={$_.UserName}}. Tuer un processus: Stop-Process -Id PID -Force. Rechercher les processus suspectes: Get-Process | Where-Object {$_.Path -like '*temp*' -or $_.Path -like '*downloads*'}"

    # --- BLOC 27 : Antivirus / EDR Presence ---
    - name: Check Antivirus and EDR Status
      win_shell: |
        try {
          $antivirusInfo = @()
          
          # Vérifier Windows Defender
          $defender = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender" -ErrorAction SilentlyContinue
          $defenderSignatures = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Signature Updates" -ErrorAction SilentlyContinue
          
          if ($defender) {
            $isDisabled = $defender.DisableAntiSpyware
            $engineVersion = $defenderSignatures.EngineVersion
            if ($isDisabled -ne 1) {
              $antivirusInfo += "WindowsDefender:Active(EngineVersion=$engineVersion)"
            } else {
              $antivirusInfo += "WindowsDefender:Disabled"
            }
          }
          
          # Vérifier les antivirus tiers via WMI
          $antivirusProducts = Get-CimInstance -Namespace "root\SecurityCenter2" -ClassName "AntiVirusProduct" -ErrorAction SilentlyContinue
          if ($antivirusProducts.Count -gt 0) {
            foreach ($av in $antivirusProducts) {
              $displayName = $av.displayName
              $productState = $av.productState
              if (($productState -band 0x1000) -eq 0x1000) {
                $antivirusInfo += "$displayName:Active"
              } else {
                $antivirusInfo += "$displayName:Inactive"
              }
            }
          }
          
          # Vérifier les EDR courants
          $edrApps = @('CrowdStrike', 'SentinelOne', 'Defender for Endpoint', 'Cylance', 'Kaspersky', 'Sophos', 'Trend Micro', 'McAfee')
          $installedSoftware = Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty DisplayName
          foreach ($edr in $edrApps) {
            if ($installedSoftware -match $edr) {
              $antivirusInfo += "$edr:Installed"
            }
          }
          
          if ($antivirusInfo.Count -gt 0) {
            Write-Output "ProtectionPresent:Yes"
            $antivirusInfo | ForEach-Object { Write-Output "- $_" }
          } else {
            Write-Output "ProtectionPresent:No/Undetected"
          }
        } catch {
          Write-Output "Error:Unable to check antivirus status"
        }
      register: antivirus_status

    - name: Record Antivirus/EDR Status
      debug:
        msg:
          task: "Antivirus / EDR Presence"
          msg: "{{ antivirus_status.stdout if antivirus_status.stdout.strip() else 'Unable to retrieve' }}"
          audit_status: "{{ 'PASS' if 'Active' in antivirus_status.stdout or 'Installed' in antivirus_status.stdout else 'FAIL' }}"
          severity: "CRITICAL"
          mitigation_advice: "La présence d'un antivirus ou EDR est essentielle. Windows Defender doit être actif par défaut. Pour une protection optimale en entreprise, déployer une solution EDR (CrowdStrike, SentinelOne, Defender for Endpoint, etc). Vérifier que les signatures sont à jour et que la protection en temps réel est activée."
          mitigation_cmd: "Vérifier Defender: Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows Defender' | Select-Object DisableAntiSpyware. Activer: Set-ItemProperty -Path 'HKLM:\\SOFTWARE\\Microsoft\\Windows Defender' -Name DisableAntiSpyware -Value 0. Vérifier EDR: Get-CimInstance -Namespace 'root\\SecurityCenter2' -ClassName 'AntiVirusProduct'"

    # --- BLOC 28 : Inventaire Détaillé des Applications Installées ---
    - name: Detailed Installed Software Inventory
      win_shell: |
        $allApps = @()
        $reg64 = Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue
        $filtered64 = $reg64 | Where-Object { $_.DisplayName }
        
        foreach ($app in $filtered64) {
          $allApps += [PSCustomObject]@{
            DisplayName = $app.DisplayName
            DisplayVersion = if ($app.DisplayVersion) { $app.DisplayVersion } else { "Unknown" }
            Publisher = if ($app.Publisher) { $app.Publisher } else { "N/A" }
            InstallDate = if ($app.InstallDate) { $app.InstallDate } else { "N/A" }
            Architecture = "64-bit"
          }
        }
        
        $reg32 = Get-ItemProperty "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" -ErrorAction SilentlyContinue
        $filtered32 = $reg32 | Where-Object { $_.DisplayName }
        
        foreach ($app in $filtered32) {
          $allApps += [PSCustomObject]@{
            DisplayName = $app.DisplayName
            DisplayVersion = if ($app.DisplayVersion) { $app.DisplayVersion } else { "Unknown" }
            Publisher = if ($app.Publisher) { $app.Publisher } else { "N/A" }
            InstallDate = if ($app.InstallDate) { $app.InstallDate } else { "N/A" }
            Architecture = "32-bit"
          }
        }
        
        $uniqueApps = $allApps | Sort-Object DisplayName -Unique
        
        if ($uniqueApps.Count -gt 0) {
          Write-Output "InstalledApplications:Count=$($uniqueApps.Count)"
          Write-Output "==========================================="
          foreach ($app in $uniqueApps) {
            Write-Output "$($app.DisplayName) | v$($app.DisplayVersion) | Publisher: $($app.Publisher) | Installed: $($app.InstallDate) | Arch: $($app.Architecture)"
          }
          Write-Output "==========================================="
        } else {
          Write-Output "NoApplicationsDetected"
        }
      register: detailed_apps_list
      ignore_errors: yes

    - name: Record Detailed Applications List
      debug:
        msg:
          task: "Detailed Installed Software Inventory"
          msg: "{{ detailed_apps_list.stdout if detailed_apps_list.stdout else 'Unable to retrieve' }}"
          audit_status: "INFO"
          severity: "INFO"
          mitigation_advice: "Audit complet de toutes les applications installées avec versions, éditeurs et dates. Cet inventaire permet de détecter: les applications non autorisées, les versions vulnérables, les doublons, les applications orphelines. Mettre à jour régulièrement et supprimer les applications non essentielles ou obsolètes."
          mitigation_cmd: "Exporter l'inventaire: Get-ItemProperty 'HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*' | Select-Object DisplayName, DisplayVersion, Publisher | Export-Csv -Path C:\\apps.csv. Ou via JSON: ConvertTo-Json | Out-File C:\\apps.json"